/* DownloadService.c generated by valac 0.16.1, the Vala compiler
 * generated from DownloadService.vala, do not modify */

/*
    DownloadService.vala
    Copyright (C) 2010 Maia Kozheva <sikon@ubuntu.com>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <gee.h>
#include <gio/gio.h>
#include <glib/gi18n-lib.h>
#include <stdio.h>


#define STEADYFLOW_CORE_TYPE_IDOWNLOAD_SERVICE (steadyflow_core_idownload_service_get_type ())
#define STEADYFLOW_CORE_IDOWNLOAD_SERVICE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), STEADYFLOW_CORE_TYPE_IDOWNLOAD_SERVICE, SteadyflowCoreIDownloadService))
#define STEADYFLOW_CORE_IS_IDOWNLOAD_SERVICE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), STEADYFLOW_CORE_TYPE_IDOWNLOAD_SERVICE))
#define STEADYFLOW_CORE_IDOWNLOAD_SERVICE_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), STEADYFLOW_CORE_TYPE_IDOWNLOAD_SERVICE, SteadyflowCoreIDownloadServiceIface))

typedef struct _SteadyflowCoreIDownloadService SteadyflowCoreIDownloadService;
typedef struct _SteadyflowCoreIDownloadServiceIface SteadyflowCoreIDownloadServiceIface;

#define STEADYFLOW_CORE_TYPE_IDOWNLOAD_FILE (steadyflow_core_idownload_file_get_type ())
#define STEADYFLOW_CORE_IDOWNLOAD_FILE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), STEADYFLOW_CORE_TYPE_IDOWNLOAD_FILE, SteadyflowCoreIDownloadFile))
#define STEADYFLOW_CORE_IS_IDOWNLOAD_FILE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), STEADYFLOW_CORE_TYPE_IDOWNLOAD_FILE))
#define STEADYFLOW_CORE_IDOWNLOAD_FILE_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), STEADYFLOW_CORE_TYPE_IDOWNLOAD_FILE, SteadyflowCoreIDownloadFileIface))

typedef struct _SteadyflowCoreIDownloadFile SteadyflowCoreIDownloadFile;
typedef struct _SteadyflowCoreIDownloadFileIface SteadyflowCoreIDownloadFileIface;

#define STEADYFLOW_CORE_IDOWNLOAD_FILE_TYPE_STATUS (steadyflow_core_idownload_file_status_get_type ())

#define STEADYFLOW_CORE_IDOWNLOAD_FILE_TYPE_FINISH_ACTION (steadyflow_core_idownload_file_finish_action_get_type ())

#define STEADYFLOW_CORE_TYPE_DOWNLOAD_SERVICE (steadyflow_core_download_service_get_type ())
#define STEADYFLOW_CORE_DOWNLOAD_SERVICE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), STEADYFLOW_CORE_TYPE_DOWNLOAD_SERVICE, SteadyflowCoreDownloadService))
#define STEADYFLOW_CORE_DOWNLOAD_SERVICE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), STEADYFLOW_CORE_TYPE_DOWNLOAD_SERVICE, SteadyflowCoreDownloadServiceClass))
#define STEADYFLOW_CORE_IS_DOWNLOAD_SERVICE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), STEADYFLOW_CORE_TYPE_DOWNLOAD_SERVICE))
#define STEADYFLOW_CORE_IS_DOWNLOAD_SERVICE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), STEADYFLOW_CORE_TYPE_DOWNLOAD_SERVICE))
#define STEADYFLOW_CORE_DOWNLOAD_SERVICE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), STEADYFLOW_CORE_TYPE_DOWNLOAD_SERVICE, SteadyflowCoreDownloadServiceClass))

typedef struct _SteadyflowCoreDownloadService SteadyflowCoreDownloadService;
typedef struct _SteadyflowCoreDownloadServiceClass SteadyflowCoreDownloadServiceClass;
typedef struct _SteadyflowCoreDownloadServicePrivate SteadyflowCoreDownloadServicePrivate;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

#define STEADYFLOW_CORE_TYPE_GIO_DOWNLOAD_FILE (steadyflow_core_gio_download_file_get_type ())
#define STEADYFLOW_CORE_GIO_DOWNLOAD_FILE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), STEADYFLOW_CORE_TYPE_GIO_DOWNLOAD_FILE, SteadyflowCoreGioDownloadFile))
#define STEADYFLOW_CORE_GIO_DOWNLOAD_FILE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), STEADYFLOW_CORE_TYPE_GIO_DOWNLOAD_FILE, SteadyflowCoreGioDownloadFileClass))
#define STEADYFLOW_CORE_IS_GIO_DOWNLOAD_FILE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), STEADYFLOW_CORE_TYPE_GIO_DOWNLOAD_FILE))
#define STEADYFLOW_CORE_IS_GIO_DOWNLOAD_FILE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), STEADYFLOW_CORE_TYPE_GIO_DOWNLOAD_FILE))
#define STEADYFLOW_CORE_GIO_DOWNLOAD_FILE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), STEADYFLOW_CORE_TYPE_GIO_DOWNLOAD_FILE, SteadyflowCoreGioDownloadFileClass))

typedef struct _SteadyflowCoreGioDownloadFile SteadyflowCoreGioDownloadFile;
typedef struct _SteadyflowCoreGioDownloadFileClass SteadyflowCoreGioDownloadFileClass;
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_key_file_free0(var) ((var == NULL) ? NULL : (var = (g_key_file_free (var), NULL)))

typedef enum  {
	STEADYFLOW_CORE_IDOWNLOAD_FILE_STATUS_CONNECTING = 0,
	STEADYFLOW_CORE_IDOWNLOAD_FILE_STATUS_DOWNLOADING,
	STEADYFLOW_CORE_IDOWNLOAD_FILE_STATUS_PAUSED,
	STEADYFLOW_CORE_IDOWNLOAD_FILE_STATUS_FINISHED,
	STEADYFLOW_CORE_IDOWNLOAD_FILE_STATUS_NETWORK_ERROR
} SteadyflowCoreIDownloadFileStatus;

typedef enum  {
	STEADYFLOW_CORE_IDOWNLOAD_FILE_FINISH_ACTION_DO_NOTHING = 0,
	STEADYFLOW_CORE_IDOWNLOAD_FILE_FINISH_ACTION_OPEN_FILE,
	STEADYFLOW_CORE_IDOWNLOAD_FILE_FINISH_ACTION_OPEN_FOLDER,
	STEADYFLOW_CORE_IDOWNLOAD_FILE_FINISH_ACTION_RUN_COMMAND
} SteadyflowCoreIDownloadFileFinishAction;

struct _SteadyflowCoreIDownloadFileIface {
	GTypeInterface parent_iface;
	void (*start) (SteadyflowCoreIDownloadFile* self, gboolean resume);
	void (*pause) (SteadyflowCoreIDownloadFile* self);
	void (*serialize) (SteadyflowCoreIDownloadFile* self, GKeyFile* file);
	SteadyflowCoreIDownloadFileStatus (*get_status) (SteadyflowCoreIDownloadFile* self);
	gint (*get_uid) (SteadyflowCoreIDownloadFile* self);
	const gchar* (*get_url) (SteadyflowCoreIDownloadFile* self);
	const gchar* (*get_local_name) (SteadyflowCoreIDownloadFile* self);
	const gchar* (*get_local_basename) (SteadyflowCoreIDownloadFile* self);
	gint64 (*get_size) (SteadyflowCoreIDownloadFile* self);
	gint64 (*get_downloaded_size) (SteadyflowCoreIDownloadFile* self);
	gint (*get_speed) (SteadyflowCoreIDownloadFile* self);
	const gchar* (*get_icon_name) (SteadyflowCoreIDownloadFile* self);
	SteadyflowCoreIDownloadFileFinishAction (*get_finish_action) (SteadyflowCoreIDownloadFile* self);
	const gchar* (*get_finish_command) (SteadyflowCoreIDownloadFile* self);
	GError* (*get_error) (SteadyflowCoreIDownloadFile* self);
};

struct _SteadyflowCoreIDownloadServiceIface {
	GTypeInterface parent_iface;
	SteadyflowCoreIDownloadFile* (*get_file_by_uid) (SteadyflowCoreIDownloadService* self, gint uid);
	SteadyflowCoreIDownloadFile* (*add_file) (SteadyflowCoreIDownloadService* self, const gchar* url, const gchar* local_name, SteadyflowCoreIDownloadFileFinishAction finish_action, const gchar* finish_command, GError** error);
	void (*remove_file) (SteadyflowCoreIDownloadService* self, SteadyflowCoreIDownloadFile* file);
	GeeList* (*get_files) (SteadyflowCoreIDownloadService* self);
};

struct _SteadyflowCoreDownloadService {
	GObject parent_instance;
	SteadyflowCoreDownloadServicePrivate * priv;
};

struct _SteadyflowCoreDownloadServiceClass {
	GObjectClass parent_class;
};

struct _SteadyflowCoreDownloadServicePrivate {
	GeeList* _files;
	gint last_uid;
};


static gpointer steadyflow_core_download_service_parent_class = NULL;
static SteadyflowCoreIDownloadServiceIface* steadyflow_core_download_service_steadyflow_core_idownload_service_parent_iface = NULL;

GType steadyflow_core_idownload_file_status_get_type (void) G_GNUC_CONST;
GType steadyflow_core_idownload_file_finish_action_get_type (void) G_GNUC_CONST;
GType steadyflow_core_idownload_file_get_type (void) G_GNUC_CONST;
GType steadyflow_core_idownload_service_get_type (void) G_GNUC_CONST;
GType steadyflow_core_download_service_get_type (void) G_GNUC_CONST;
#define STEADYFLOW_CORE_DOWNLOAD_SERVICE_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), STEADYFLOW_CORE_TYPE_DOWNLOAD_SERVICE, SteadyflowCoreDownloadServicePrivate))
enum  {
	STEADYFLOW_CORE_DOWNLOAD_SERVICE_DUMMY_PROPERTY,
	STEADYFLOW_CORE_DOWNLOAD_SERVICE_FILES
};
static void steadyflow_core_download_service_save_state (SteadyflowCoreDownloadService* self);
SteadyflowCoreDownloadService* steadyflow_core_download_service_new (void);
SteadyflowCoreDownloadService* steadyflow_core_download_service_construct (GType object_type);
static void steadyflow_core_download_service_load_state (SteadyflowCoreDownloadService* self);
static SteadyflowCoreIDownloadFile* steadyflow_core_download_service_real_get_file_by_uid (SteadyflowCoreIDownloadService* base, gint uid);
GeeList* steadyflow_core_idownload_service_get_files (SteadyflowCoreIDownloadService* self);
gint steadyflow_core_idownload_file_get_uid (SteadyflowCoreIDownloadFile* self);
static SteadyflowCoreIDownloadFile* steadyflow_core_download_service_real_add_file (SteadyflowCoreIDownloadService* base, const gchar* url, const gchar* local_name, SteadyflowCoreIDownloadFileFinishAction finish_action, const gchar* finish_command, GError** error);
SteadyflowCoreGioDownloadFile* steadyflow_core_gio_download_file_new (const gchar* url, const gchar* local_name, gint uid, SteadyflowCoreIDownloadFileFinishAction finish_action, const gchar* finish_command);
SteadyflowCoreGioDownloadFile* steadyflow_core_gio_download_file_construct (GType object_type, const gchar* url, const gchar* local_name, gint uid, SteadyflowCoreIDownloadFileFinishAction finish_action, const gchar* finish_command);
GType steadyflow_core_gio_download_file_get_type (void) G_GNUC_CONST;
void steadyflow_core_idownload_file_start (SteadyflowCoreIDownloadFile* self, gboolean resume);
static void __lambda3_ (SteadyflowCoreDownloadService* self, SteadyflowCoreIDownloadFileStatus status);
static void ___lambda3__steadyflow_core_idownload_file_status_changed (SteadyflowCoreIDownloadFile* _sender, SteadyflowCoreIDownloadFileStatus old_status, gpointer self);
static void steadyflow_core_download_service_real_remove_file (SteadyflowCoreIDownloadService* base, SteadyflowCoreIDownloadFile* file);
static GFile* steadyflow_core_download_service_get_state_file (SteadyflowCoreDownloadService* self);
void steadyflow_core_util_fatal_error (GError* e, const gchar* message);
SteadyflowCoreIDownloadFile* steadyflow_core_gio_download_file_deserialize (GKeyFile* keys, gint uid, gboolean* should_start, GError** error);
static void _____lambda2_ (SteadyflowCoreDownloadService* self, SteadyflowCoreIDownloadFileStatus status);
static void ______lambda2__steadyflow_core_idownload_file_status_changed (SteadyflowCoreIDownloadFile* _sender, SteadyflowCoreIDownloadFileStatus old_status, gpointer self);
void steadyflow_core_idownload_file_serialize (SteadyflowCoreIDownloadFile* self, GKeyFile* file);
static void steadyflow_core_download_service_finalize (GObject* obj);
static void _vala_steadyflow_core_download_service_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);


SteadyflowCoreDownloadService* steadyflow_core_download_service_construct (GType object_type) {
	SteadyflowCoreDownloadService * self = NULL;
	GeeArrayList* _tmp0_;
	self = (SteadyflowCoreDownloadService*) g_object_new (object_type, NULL);
	_tmp0_ = gee_array_list_new (STEADYFLOW_CORE_TYPE_IDOWNLOAD_FILE, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL);
	_g_object_unref0 (self->priv->_files);
	self->priv->_files = (GeeList*) _tmp0_;
	self->priv->last_uid = 0;
	steadyflow_core_download_service_load_state (self);
	return self;
}


SteadyflowCoreDownloadService* steadyflow_core_download_service_new (void) {
	return steadyflow_core_download_service_construct (STEADYFLOW_CORE_TYPE_DOWNLOAD_SERVICE);
}


static SteadyflowCoreIDownloadFile* steadyflow_core_download_service_real_get_file_by_uid (SteadyflowCoreIDownloadService* base, gint uid) {
	SteadyflowCoreDownloadService * self;
	SteadyflowCoreIDownloadFile* result = NULL;
	self = (SteadyflowCoreDownloadService*) base;
	{
		GeeList* _tmp0_;
		GeeList* _tmp1_;
		GeeList* _file_list;
		GeeList* _tmp2_;
		gint _tmp3_;
		gint _tmp4_;
		gint _file_size;
		gint _file_index;
		_tmp0_ = steadyflow_core_idownload_service_get_files ((SteadyflowCoreIDownloadService*) self);
		_tmp1_ = _tmp0_;
		_file_list = _tmp1_;
		_tmp2_ = _file_list;
		_tmp3_ = gee_collection_get_size ((GeeCollection*) _tmp2_);
		_tmp4_ = _tmp3_;
		_file_size = _tmp4_;
		_file_index = -1;
		while (TRUE) {
			gint _tmp5_;
			gint _tmp6_;
			gint _tmp7_;
			GeeList* _tmp8_;
			gint _tmp9_;
			gpointer _tmp10_ = NULL;
			SteadyflowCoreIDownloadFile* file;
			SteadyflowCoreIDownloadFile* _tmp11_;
			gint _tmp12_;
			gint _tmp13_;
			gint _tmp14_;
			_tmp5_ = _file_index;
			_file_index = _tmp5_ + 1;
			_tmp6_ = _file_index;
			_tmp7_ = _file_size;
			if (!(_tmp6_ < _tmp7_)) {
				break;
			}
			_tmp8_ = _file_list;
			_tmp9_ = _file_index;
			_tmp10_ = gee_list_get (_tmp8_, _tmp9_);
			file = (SteadyflowCoreIDownloadFile*) _tmp10_;
			_tmp11_ = file;
			_tmp12_ = steadyflow_core_idownload_file_get_uid (_tmp11_);
			_tmp13_ = _tmp12_;
			_tmp14_ = uid;
			if (_tmp13_ == _tmp14_) {
				result = file;
				_g_object_unref0 (_file_list);
				return result;
			}
			_g_object_unref0 (file);
		}
		_g_object_unref0 (_file_list);
	}
	result = NULL;
	return result;
}


static void __lambda3_ (SteadyflowCoreDownloadService* self, SteadyflowCoreIDownloadFileStatus status) {
	steadyflow_core_download_service_save_state (self);
}


static void ___lambda3__steadyflow_core_idownload_file_status_changed (SteadyflowCoreIDownloadFile* _sender, SteadyflowCoreIDownloadFileStatus old_status, gpointer self) {
	__lambda3_ (self, old_status);
}


static SteadyflowCoreIDownloadFile* steadyflow_core_download_service_real_add_file (SteadyflowCoreIDownloadService* base, const gchar* url, const gchar* local_name, SteadyflowCoreIDownloadFileFinishAction finish_action, const gchar* finish_command, GError** error) {
	SteadyflowCoreDownloadService * self;
	SteadyflowCoreIDownloadFile* result = NULL;
	const gchar* _tmp0_;
	const gchar* _tmp1_;
	gint _tmp2_;
	SteadyflowCoreIDownloadFileFinishAction _tmp3_;
	const gchar* _tmp4_;
	SteadyflowCoreGioDownloadFile* _tmp5_;
	SteadyflowCoreIDownloadFile* file;
	gint _tmp6_;
	GeeList* _tmp7_;
	self = (SteadyflowCoreDownloadService*) base;
	g_return_val_if_fail (url != NULL, NULL);
	g_return_val_if_fail (local_name != NULL, NULL);
	_tmp0_ = url;
	_tmp1_ = local_name;
	_tmp2_ = self->priv->last_uid;
	_tmp3_ = finish_action;
	_tmp4_ = finish_command;
	_tmp5_ = steadyflow_core_gio_download_file_new (_tmp0_, _tmp1_, _tmp2_, _tmp3_, _tmp4_);
	file = (SteadyflowCoreIDownloadFile*) _tmp5_;
	_tmp6_ = self->priv->last_uid;
	self->priv->last_uid = _tmp6_ + 1;
	steadyflow_core_idownload_file_start (file, FALSE);
	_tmp7_ = self->priv->_files;
	gee_collection_add ((GeeCollection*) _tmp7_, file);
	g_signal_emit_by_name ((SteadyflowCoreIDownloadService*) self, "file-added", file);
	g_signal_connect_object (file, "status-changed", (GCallback) ___lambda3__steadyflow_core_idownload_file_status_changed, self, 0);
	result = file;
	return result;
}


static void steadyflow_core_download_service_real_remove_file (SteadyflowCoreIDownloadService* base, SteadyflowCoreIDownloadFile* file) {
	SteadyflowCoreDownloadService * self;
	GeeList* _tmp0_;
	SteadyflowCoreIDownloadFile* _tmp1_;
	SteadyflowCoreIDownloadFile* _tmp2_;
	self = (SteadyflowCoreDownloadService*) base;
	g_return_if_fail (file != NULL);
	_tmp0_ = self->priv->_files;
	_tmp1_ = file;
	gee_collection_remove ((GeeCollection*) _tmp0_, _tmp1_);
	steadyflow_core_download_service_save_state (self);
	_tmp2_ = file;
	g_signal_emit_by_name ((SteadyflowCoreIDownloadService*) self, "file-removed", _tmp2_);
}


static GFile* steadyflow_core_download_service_get_state_file (SteadyflowCoreDownloadService* self) {
	GFile* result = NULL;
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_;
	gchar* config_dir;
	const gchar* _tmp2_;
	GFile* _tmp3_ = NULL;
	GFile* _tmp4_;
	GFile* _tmp5_ = NULL;
	GFile* _tmp6_;
	GFile* subdir;
	GFile* _tmp14_;
	GFile* _tmp15_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = g_get_user_data_dir ();
	_tmp1_ = g_strdup (_tmp0_);
	config_dir = _tmp1_;
	_tmp2_ = config_dir;
	_tmp3_ = g_file_new_for_path (_tmp2_);
	_tmp4_ = _tmp3_;
	_tmp5_ = g_file_get_child (_tmp4_, "steadyflow");
	_tmp6_ = _tmp5_;
	_g_object_unref0 (_tmp4_);
	subdir = _tmp6_;
	{
		GFile* _tmp7_;
		gboolean _tmp8_ = FALSE;
		_tmp7_ = subdir;
		_tmp8_ = g_file_query_exists (_tmp7_, NULL);
		if (!_tmp8_) {
			GFile* _tmp9_;
			_tmp9_ = subdir;
			g_file_make_directory_with_parents (_tmp9_, NULL, &_inner_error_);
			if (_inner_error_ != NULL) {
				goto __catch0_g_error;
			}
		} else {
			GFile* _tmp10_;
			GFileType _tmp11_ = 0;
			_tmp10_ = subdir;
			_tmp11_ = g_file_query_file_type (_tmp10_, G_FILE_QUERY_INFO_NONE, NULL);
			if (_tmp11_ != G_FILE_TYPE_DIRECTORY) {
				const gchar* _tmp12_ = NULL;
				GError* _tmp13_;
				_tmp12_ = _ ("Cannot create settings directory - a non-directory with that name alre" \
"ady exists");
				_tmp13_ = g_error_new_literal (G_FILE_ERROR, G_FILE_ERROR_NOTDIR, _tmp12_);
				_inner_error_ = _tmp13_;
				goto __catch0_g_error;
			}
		}
	}
	goto __finally0;
	__catch0_g_error:
	{
		GError* e = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		steadyflow_core_util_fatal_error (e, NULL);
		_g_error_free0 (e);
	}
	__finally0:
	if (_inner_error_ != NULL) {
		_g_object_unref0 (subdir);
		_g_free0 (config_dir);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	_tmp14_ = subdir;
	_tmp15_ = g_file_get_child (_tmp14_, "downloads.ini");
	result = _tmp15_;
	_g_object_unref0 (subdir);
	_g_free0 (config_dir);
	return result;
}


static void _____lambda2_ (SteadyflowCoreDownloadService* self, SteadyflowCoreIDownloadFileStatus status) {
	steadyflow_core_download_service_save_state (self);
}


static void ______lambda2__steadyflow_core_idownload_file_status_changed (SteadyflowCoreIDownloadFile* _sender, SteadyflowCoreIDownloadFileStatus old_status, gpointer self) {
	_____lambda2_ (self, old_status);
}


static void steadyflow_core_download_service_load_state (SteadyflowCoreDownloadService* self) {
	GKeyFile* _tmp0_;
	GKeyFile* keys;
	gint max_uid;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_key_file_new ();
	keys = _tmp0_;
	max_uid = 0;
	{
		GKeyFile* _tmp1_;
		GFile* _tmp2_ = NULL;
		GFile* _tmp3_;
		gchar* _tmp4_ = NULL;
		gchar* _tmp5_;
		GKeyFile* _tmp6_;
		gsize _tmp7_;
		gchar** _tmp8_ = NULL;
		gint _tmp25_;
		_tmp1_ = keys;
		_tmp2_ = steadyflow_core_download_service_get_state_file (self);
		_tmp3_ = _tmp2_;
		_tmp4_ = g_file_get_path (_tmp3_);
		_tmp5_ = _tmp4_;
		g_key_file_load_from_file (_tmp1_, _tmp5_, G_KEY_FILE_NONE, &_inner_error_);
		_g_free0 (_tmp5_);
		_g_object_unref0 (_tmp3_);
		if (_inner_error_ != NULL) {
			goto __catch1_g_error;
		}
		_tmp6_ = keys;
		_tmp8_ = g_key_file_get_groups (_tmp6_, &_tmp7_);
		{
			gchar** group_collection = NULL;
			gint group_collection_length1 = 0;
			gint _group_collection_size_ = 0;
			gint group_it = 0;
			group_collection = _tmp8_;
			group_collection_length1 = _tmp7_;
			for (group_it = 0; group_it < _tmp7_; group_it = group_it + 1) {
				gchar* _tmp9_;
				gchar* group = NULL;
				_tmp9_ = g_strdup (group_collection[group_it]);
				group = _tmp9_;
				{
					const gchar* _tmp10_;
					gboolean should_start;
					const gchar* _tmp11_;
					gint _tmp12_ = 0;
					gint uid;
					GKeyFile* _tmp13_;
					gint _tmp14_;
					gboolean _tmp15_ = FALSE;
					SteadyflowCoreIDownloadFile* _tmp16_ = NULL;
					SteadyflowCoreIDownloadFile* file;
					gint _tmp17_;
					gint _tmp18_;
					GeeList* _tmp20_;
					SteadyflowCoreIDownloadFile* _tmp21_;
					SteadyflowCoreIDownloadFile* _tmp22_;
					gboolean _tmp23_;
					_tmp10_ = group;
					if (g_strcmp0 (_tmp10_, "ROOT") == 0) {
						_g_free0 (group);
						continue;
					}
					should_start = FALSE;
					_tmp11_ = group;
					_tmp12_ = atoi (_tmp11_);
					uid = _tmp12_;
					_tmp13_ = keys;
					_tmp14_ = uid;
					_tmp16_ = steadyflow_core_gio_download_file_deserialize (_tmp13_, _tmp14_, &_tmp15_, &_inner_error_);
					should_start = _tmp15_;
					file = _tmp16_;
					if (_inner_error_ != NULL) {
						_g_free0 (group);
						group_collection = (_vala_array_free (group_collection, group_collection_length1, (GDestroyNotify) g_free), NULL);
						goto __catch1_g_error;
					}
					_tmp17_ = uid;
					_tmp18_ = max_uid;
					if (_tmp17_ > _tmp18_) {
						gint _tmp19_;
						_tmp19_ = uid;
						max_uid = _tmp19_;
					}
					_tmp20_ = self->priv->_files;
					_tmp21_ = file;
					gee_collection_add ((GeeCollection*) _tmp20_, _tmp21_);
					_tmp22_ = file;
					g_signal_connect_object (_tmp22_, "status-changed", (GCallback) ______lambda2__steadyflow_core_idownload_file_status_changed, self, 0);
					_tmp23_ = should_start;
					if (_tmp23_) {
						SteadyflowCoreIDownloadFile* _tmp24_;
						_tmp24_ = file;
						steadyflow_core_idownload_file_start (_tmp24_, TRUE);
					}
					_g_object_unref0 (file);
					_g_free0 (group);
				}
			}
			group_collection = (_vala_array_free (group_collection, group_collection_length1, (GDestroyNotify) g_free), NULL);
		}
		_tmp25_ = max_uid;
		self->priv->last_uid = _tmp25_ + 1;
	}
	goto __finally1;
	__catch1_g_error:
	{
		GError* e = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_g_error_free0 (e);
	}
	__finally1:
	if (_inner_error_ != NULL) {
		_g_key_file_free0 (keys);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	_g_key_file_free0 (keys);
}


static guint8* string_get_data (const gchar* self, int* result_length1) {
	guint8* result;
	guint8* res;
	gint res_length1;
	gint _res_size_;
	gint _tmp0_;
	gint _tmp1_;
	gint _tmp2_;
	guint8* _tmp3_;
	gint _tmp3__length1;
	guint8* _tmp4_;
	gint _tmp4__length1;
	g_return_val_if_fail (self != NULL, NULL);
	res = (guint8*) self;
	res_length1 = -1;
	_res_size_ = res_length1;
	_tmp0_ = strlen (self);
	_tmp1_ = _tmp0_;
	res_length1 = (gint) _tmp1_;
	_tmp2_ = res_length1;
	_tmp3_ = res;
	_tmp3__length1 = res_length1;
	_tmp4_ = _tmp3_;
	_tmp4__length1 = _tmp3__length1;
	if (result_length1) {
		*result_length1 = _tmp4__length1;
	}
	result = _tmp4_;
	return result;
}


static void steadyflow_core_download_service_save_state (SteadyflowCoreDownloadService* self) {
	GKeyFile* _tmp0_;
	GKeyFile* keys;
	GKeyFile* _tmp14_;
	gchar* _tmp15_ = NULL;
	gchar* file_contents;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_key_file_new ();
	keys = _tmp0_;
	{
		GeeList* _tmp1_;
		GeeList* _tmp2_;
		GeeList* _file_list;
		GeeList* _tmp3_;
		gint _tmp4_;
		gint _tmp5_;
		gint _file_size;
		gint _file_index;
		_tmp1_ = steadyflow_core_idownload_service_get_files ((SteadyflowCoreIDownloadService*) self);
		_tmp2_ = _tmp1_;
		_file_list = _tmp2_;
		_tmp3_ = _file_list;
		_tmp4_ = gee_collection_get_size ((GeeCollection*) _tmp3_);
		_tmp5_ = _tmp4_;
		_file_size = _tmp5_;
		_file_index = -1;
		while (TRUE) {
			gint _tmp6_;
			gint _tmp7_;
			gint _tmp8_;
			GeeList* _tmp9_;
			gint _tmp10_;
			gpointer _tmp11_ = NULL;
			SteadyflowCoreIDownloadFile* file;
			SteadyflowCoreIDownloadFile* _tmp12_;
			GKeyFile* _tmp13_;
			_tmp6_ = _file_index;
			_file_index = _tmp6_ + 1;
			_tmp7_ = _file_index;
			_tmp8_ = _file_size;
			if (!(_tmp7_ < _tmp8_)) {
				break;
			}
			_tmp9_ = _file_list;
			_tmp10_ = _file_index;
			_tmp11_ = gee_list_get (_tmp9_, _tmp10_);
			file = (SteadyflowCoreIDownloadFile*) _tmp11_;
			_tmp12_ = file;
			_tmp13_ = keys;
			steadyflow_core_idownload_file_serialize (_tmp12_, _tmp13_);
			_g_object_unref0 (file);
		}
		_g_object_unref0 (_file_list);
	}
	_tmp14_ = keys;
	_tmp15_ = g_key_file_to_data (_tmp14_, NULL, NULL);
	file_contents = _tmp15_;
	{
		GFile* _tmp16_ = NULL;
		GFile* _tmp17_;
		guint8* _tmp18_;
		gint _tmp18__length1;
		guint8* _tmp19_;
		gint _tmp19__length1;
		_tmp16_ = steadyflow_core_download_service_get_state_file (self);
		_tmp17_ = _tmp16_;
		_tmp18_ = string_get_data (file_contents, &_tmp18__length1);
		_tmp19_ = _tmp18_;
		_tmp19__length1 = _tmp18__length1;
		g_file_replace_contents (_tmp17_, _tmp19_, (gsize) _tmp19__length1, NULL, FALSE, G_FILE_CREATE_NONE, NULL, NULL, &_inner_error_);
		_g_object_unref0 (_tmp17_);
		if (_inner_error_ != NULL) {
			goto __catch2_g_error;
		}
	}
	goto __finally2;
	__catch2_g_error:
	{
		GError* e = NULL;
		FILE* _tmp20_;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp20_ = stderr;
		fprintf (_tmp20_, "Cannot save downloads state");
		_g_error_free0 (e);
	}
	__finally2:
	if (_inner_error_ != NULL) {
		_g_free0 (file_contents);
		_g_key_file_free0 (keys);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	_g_free0 (file_contents);
	_g_key_file_free0 (keys);
}


static GeeList* steadyflow_core_download_service_real_get_files (SteadyflowCoreIDownloadService* base) {
	GeeList* result;
	SteadyflowCoreDownloadService* self;
	GeeList* _tmp0_;
	GeeList* _tmp1_;
	GeeList* _tmp2_;
	self = (SteadyflowCoreDownloadService*) base;
	_tmp0_ = self->priv->_files;
	_tmp1_ = gee_list_get_read_only_view (_tmp0_);
	_tmp2_ = _tmp1_;
	result = _tmp2_;
	return result;
}


static void steadyflow_core_download_service_class_init (SteadyflowCoreDownloadServiceClass * klass) {
	steadyflow_core_download_service_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (SteadyflowCoreDownloadServicePrivate));
	G_OBJECT_CLASS (klass)->get_property = _vala_steadyflow_core_download_service_get_property;
	G_OBJECT_CLASS (klass)->finalize = steadyflow_core_download_service_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), STEADYFLOW_CORE_DOWNLOAD_SERVICE_FILES, g_param_spec_object ("files", "files", "files", GEE_TYPE_LIST, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
}


static void steadyflow_core_download_service_steadyflow_core_idownload_service_interface_init (SteadyflowCoreIDownloadServiceIface * iface) {
	steadyflow_core_download_service_steadyflow_core_idownload_service_parent_iface = g_type_interface_peek_parent (iface);
	iface->get_file_by_uid = (SteadyflowCoreIDownloadFile* (*)(SteadyflowCoreIDownloadService*, gint)) steadyflow_core_download_service_real_get_file_by_uid;
	iface->add_file = (SteadyflowCoreIDownloadFile* (*)(SteadyflowCoreIDownloadService*, const gchar*, const gchar*, SteadyflowCoreIDownloadFileFinishAction, const gchar*, GError**)) steadyflow_core_download_service_real_add_file;
	iface->remove_file = (void (*)(SteadyflowCoreIDownloadService*, SteadyflowCoreIDownloadFile*)) steadyflow_core_download_service_real_remove_file;
	iface->get_files = steadyflow_core_download_service_real_get_files;
}


static void steadyflow_core_download_service_instance_init (SteadyflowCoreDownloadService * self) {
	self->priv = STEADYFLOW_CORE_DOWNLOAD_SERVICE_GET_PRIVATE (self);
}


static void steadyflow_core_download_service_finalize (GObject* obj) {
	SteadyflowCoreDownloadService * self;
	self = STEADYFLOW_CORE_DOWNLOAD_SERVICE (obj);
	steadyflow_core_download_service_save_state (self);
	_g_object_unref0 (self->priv->_files);
	G_OBJECT_CLASS (steadyflow_core_download_service_parent_class)->finalize (obj);
}


GType steadyflow_core_download_service_get_type (void) {
	static volatile gsize steadyflow_core_download_service_type_id__volatile = 0;
	if (g_once_init_enter (&steadyflow_core_download_service_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (SteadyflowCoreDownloadServiceClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) steadyflow_core_download_service_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (SteadyflowCoreDownloadService), 0, (GInstanceInitFunc) steadyflow_core_download_service_instance_init, NULL };
		static const GInterfaceInfo steadyflow_core_idownload_service_info = { (GInterfaceInitFunc) steadyflow_core_download_service_steadyflow_core_idownload_service_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
		GType steadyflow_core_download_service_type_id;
		steadyflow_core_download_service_type_id = g_type_register_static (G_TYPE_OBJECT, "SteadyflowCoreDownloadService", &g_define_type_info, 0);
		g_type_add_interface_static (steadyflow_core_download_service_type_id, STEADYFLOW_CORE_TYPE_IDOWNLOAD_SERVICE, &steadyflow_core_idownload_service_info);
		g_once_init_leave (&steadyflow_core_download_service_type_id__volatile, steadyflow_core_download_service_type_id);
	}
	return steadyflow_core_download_service_type_id__volatile;
}


static void _vala_steadyflow_core_download_service_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	SteadyflowCoreDownloadService * self;
	self = STEADYFLOW_CORE_DOWNLOAD_SERVICE (object);
	switch (property_id) {
		case STEADYFLOW_CORE_DOWNLOAD_SERVICE_FILES:
		g_value_take_object (value, steadyflow_core_idownload_service_get_files ((SteadyflowCoreIDownloadService*) self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}



