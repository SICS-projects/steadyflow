/* OptionParser.c generated by valac 0.16.1, the Vala compiler
 * generated from OptionParser.vala, do not modify */

/*
    OptionParser.vala
    Copyright (C) 2010 Maia Kozheva <sikon@ubuntu.com>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <gee.h>


#define STEADYFLOW_CORE_TYPE_OPTION_PARSER (steadyflow_core_option_parser_get_type ())
#define STEADYFLOW_CORE_OPTION_PARSER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), STEADYFLOW_CORE_TYPE_OPTION_PARSER, SteadyflowCoreOptionParser))
#define STEADYFLOW_CORE_OPTION_PARSER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), STEADYFLOW_CORE_TYPE_OPTION_PARSER, SteadyflowCoreOptionParserClass))
#define STEADYFLOW_CORE_IS_OPTION_PARSER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), STEADYFLOW_CORE_TYPE_OPTION_PARSER))
#define STEADYFLOW_CORE_IS_OPTION_PARSER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), STEADYFLOW_CORE_TYPE_OPTION_PARSER))
#define STEADYFLOW_CORE_OPTION_PARSER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), STEADYFLOW_CORE_TYPE_OPTION_PARSER, SteadyflowCoreOptionParserClass))

typedef struct _SteadyflowCoreOptionParser SteadyflowCoreOptionParser;
typedef struct _SteadyflowCoreOptionParserClass SteadyflowCoreOptionParserClass;
typedef struct _SteadyflowCoreOptionParserPrivate SteadyflowCoreOptionParserPrivate;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
typedef struct _Block1Data Block1Data;
#define _g_free0(var) (var = (g_free (var), NULL))

struct _SteadyflowCoreOptionParser {
	GObject parent_instance;
	SteadyflowCoreOptionParserPrivate * priv;
};

struct _SteadyflowCoreOptionParserClass {
	GObjectClass parent_class;
};

struct _SteadyflowCoreOptionParserPrivate {
	gchar** args;
	gint args_length1;
	gint _args_size_;
	GeeSet* commands;
};

typedef void (*SteadyflowCoreOptionParserOptionCommand) (gchar** args, int args_length1, GeeMap* kwargs, void* user_data);
struct _Block1Data {
	int _ref_count_;
	SteadyflowCoreOptionParser * self;
	SteadyflowCoreOptionParserOptionCommand handler;
	gpointer handler_target;
};


static gpointer steadyflow_core_option_parser_parent_class = NULL;

GType steadyflow_core_option_parser_get_type (void) G_GNUC_CONST;
#define STEADYFLOW_CORE_OPTION_PARSER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), STEADYFLOW_CORE_TYPE_OPTION_PARSER, SteadyflowCoreOptionParserPrivate))
enum  {
	STEADYFLOW_CORE_OPTION_PARSER_DUMMY_PROPERTY
};
SteadyflowCoreOptionParser* steadyflow_core_option_parser_new (gchar** args, int args_length1, gboolean remove_arg0);
SteadyflowCoreOptionParser* steadyflow_core_option_parser_construct (GType object_type, gchar** args, int args_length1, gboolean remove_arg0);
static gchar** _vala_array_dup1 (gchar** self, int length);
void steadyflow_core_option_parser_register_command (SteadyflowCoreOptionParser* self, const gchar* cmd, SteadyflowCoreOptionParserOptionCommand handler, void* handler_target);
static Block1Data* block1_data_ref (Block1Data* _data1_);
static void block1_data_unref (void * _userdata_);
static void __lambda5_ (Block1Data* _data1_, gchar** args, int args_length1, GeeMap* kwargs);
static void ___lambda5__steadyflow_core_option_parser_command (SteadyflowCoreOptionParser* _sender, gchar** args, int args_length1, GeeMap* kwargs, gpointer self);
void steadyflow_core_option_parser_run (SteadyflowCoreOptionParser* self);
static gchar** _vala_array_dup2 (gchar** self, int length);
static gchar** _vala_array_dup3 (gchar** self, int length);
static void g_cclosure_user_marshal_VOID__BOXED_INT_OBJECT (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data);
static void steadyflow_core_option_parser_finalize (GObject* obj);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
static gint _vala_array_length (gpointer array);


static gchar** _vala_array_dup1 (gchar** self, int length) {
	gchar** result;
	int i;
	result = g_new0 (gchar*, length + 1);
	for (i = 0; i < length; i++) {
		gchar* _tmp0_;
		_tmp0_ = g_strdup (self[i]);
		result[i] = _tmp0_;
	}
	return result;
}


SteadyflowCoreOptionParser* steadyflow_core_option_parser_construct (GType object_type, gchar** args, int args_length1, gboolean remove_arg0) {
	SteadyflowCoreOptionParser * self = NULL;
	gchar** _tmp0_ = NULL;
	gint _tmp0__length1 = 0;
	gint __tmp0__size_ = 0;
	gboolean _tmp1_;
	gchar** _tmp5_;
	gint _tmp5__length1;
	gchar** _tmp6_;
	gint _tmp6__length1;
	GeeHashSet* _tmp7_;
	self = (SteadyflowCoreOptionParser*) g_object_new (object_type, NULL);
	_tmp1_ = remove_arg0;
	if (_tmp1_) {
		gchar** _tmp2_;
		gint _tmp2__length1;
		gchar** _tmp3_;
		gint _tmp3__length1;
		_tmp2_ = args;
		_tmp2__length1 = args_length1;
		_tmp3_ = args;
		_tmp3__length1 = args_length1;
		_tmp0_ = _tmp2_ + 1;
		_tmp0__length1 = _tmp3__length1 - 1;
		__tmp0__size_ = _tmp0__length1;
	} else {
		gchar** _tmp4_;
		gint _tmp4__length1;
		_tmp4_ = args;
		_tmp4__length1 = args_length1;
		_tmp0_ = _tmp4_;
		_tmp0__length1 = _tmp4__length1;
		__tmp0__size_ = _tmp0__length1;
	}
	_tmp5_ = _tmp0_;
	_tmp5__length1 = _tmp0__length1;
	_tmp6_ = (_tmp5_ != NULL) ? _vala_array_dup1 (_tmp5_, _tmp5__length1) : ((gpointer) _tmp5_);
	_tmp6__length1 = _tmp5__length1;
	self->priv->args = (_vala_array_free (self->priv->args, self->priv->args_length1, (GDestroyNotify) g_free), NULL);
	self->priv->args = _tmp6_;
	self->priv->args_length1 = _tmp6__length1;
	self->priv->_args_size_ = self->priv->args_length1;
	_tmp7_ = gee_hash_set_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, NULL, NULL);
	_g_object_unref0 (self->priv->commands);
	self->priv->commands = (GeeSet*) _tmp7_;
	return self;
}


SteadyflowCoreOptionParser* steadyflow_core_option_parser_new (gchar** args, int args_length1, gboolean remove_arg0) {
	return steadyflow_core_option_parser_construct (STEADYFLOW_CORE_TYPE_OPTION_PARSER, args, args_length1, remove_arg0);
}


static Block1Data* block1_data_ref (Block1Data* _data1_) {
	g_atomic_int_inc (&_data1_->_ref_count_);
	return _data1_;
}


static void block1_data_unref (void * _userdata_) {
	Block1Data* _data1_;
	_data1_ = (Block1Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data1_->_ref_count_)) {
		SteadyflowCoreOptionParser * self;
		self = _data1_->self;
		_g_object_unref0 (self);
		g_slice_free (Block1Data, _data1_);
	}
}


static void __lambda5_ (Block1Data* _data1_, gchar** args, int args_length1, GeeMap* kwargs) {
	SteadyflowCoreOptionParser * self;
	SteadyflowCoreOptionParserOptionCommand _tmp0_;
	void* _tmp0__target;
	gchar** _tmp1_;
	gint _tmp1__length1;
	GeeMap* _tmp2_;
	self = _data1_->self;
	g_return_if_fail (kwargs != NULL);
	_tmp0_ = _data1_->handler;
	_tmp0__target = _data1_->handler_target;
	_tmp1_ = args;
	_tmp1__length1 = args_length1;
	_tmp2_ = kwargs;
	_tmp0_ (_tmp1_, _tmp1__length1, _tmp2_, _tmp0__target);
}


static void ___lambda5__steadyflow_core_option_parser_command (SteadyflowCoreOptionParser* _sender, gchar** args, int args_length1, GeeMap* kwargs, gpointer self) {
	__lambda5_ (self, args, args_length1, kwargs);
}


void steadyflow_core_option_parser_register_command (SteadyflowCoreOptionParser* self, const gchar* cmd, SteadyflowCoreOptionParserOptionCommand handler, void* handler_target) {
	Block1Data* _data1_;
	SteadyflowCoreOptionParserOptionCommand _tmp0_;
	void* _tmp0__target;
	GeeSet* _tmp1_;
	const gchar* _tmp2_;
	const gchar* _tmp3_;
	gchar* _tmp4_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (cmd != NULL);
	_data1_ = g_slice_new0 (Block1Data);
	_data1_->_ref_count_ = 1;
	_data1_->self = g_object_ref (self);
	_tmp0_ = handler;
	_tmp0__target = handler_target;
	_data1_->handler = _tmp0_;
	_data1_->handler_target = _tmp0__target;
	_tmp1_ = self->priv->commands;
	_tmp2_ = cmd;
	gee_collection_add ((GeeCollection*) _tmp1_, _tmp2_);
	_tmp3_ = cmd;
	_tmp4_ = g_strconcat ("command::", _tmp3_, NULL);
	g_signal_connect_data (self, _tmp4_, (GCallback) ___lambda5__steadyflow_core_option_parser_command, block1_data_ref (_data1_), (GClosureNotify) block1_data_unref, 0);
	_g_free0 (_tmp4_);
	block1_data_unref (_data1_);
	_data1_ = NULL;
}


static gchar** _vala_array_dup2 (gchar** self, int length) {
	gchar** result;
	int i;
	result = g_new0 (gchar*, length + 1);
	for (i = 0; i < length; i++) {
		gchar* _tmp0_;
		_tmp0_ = g_strdup (self[i]);
		result[i] = _tmp0_;
	}
	return result;
}


static gchar string_get (const gchar* self, glong index) {
	gchar result = '\0';
	glong _tmp0_;
	gchar _tmp1_;
	g_return_val_if_fail (self != NULL, '\0');
	_tmp0_ = index;
	_tmp1_ = ((gchar*) self)[_tmp0_];
	result = _tmp1_;
	return result;
}


static gchar** _vala_array_dup3 (gchar** self, int length) {
	gchar** result;
	int i;
	result = g_new0 (gchar*, length + 1);
	for (i = 0; i < length; i++) {
		gchar* _tmp0_;
		_tmp0_ = g_strdup (self[i]);
		result[i] = _tmp0_;
	}
	return result;
}


void steadyflow_core_option_parser_run (SteadyflowCoreOptionParser* self) {
	GeeArrayList* _tmp0_;
	GeeList* arglist;
	GeeHashMap* _tmp1_;
	GeeMap* kwargs;
	gchar** _tmp2_;
	gint _tmp2__length1;
	gchar* _tmp5_;
	gchar* cmd;
	gchar** _tmp6_;
	gint _tmp6__length1;
	gchar** _tmp7_;
	gint _tmp7__length1;
	gchar** arguments;
	gint arguments_length1;
	gint _arguments_size_;
	gchar** _tmp8_;
	gint _tmp8__length1;
	const gchar* _tmp9_;
	gchar _tmp10_ = '\0';
	gchar** _tmp17_;
	gint _tmp17__length1;
	gboolean _tmp34_ = FALSE;
	const gchar* _tmp35_;
	gboolean _tmp39_;
	g_return_if_fail (self != NULL);
	_tmp0_ = gee_array_list_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, NULL);
	arglist = (GeeList*) _tmp0_;
	_tmp1_ = gee_hash_map_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, NULL, NULL, NULL);
	kwargs = (GeeMap*) _tmp1_;
	_tmp2_ = self->priv->args;
	_tmp2__length1 = self->priv->args_length1;
	if (_tmp2__length1 == 0) {
		gchar** _tmp3_;
		gint _tmp3__length1;
		GeeMap* _tmp4_;
		_tmp3_ = self->priv->args;
		_tmp3__length1 = self->priv->args_length1;
		_tmp4_ = kwargs;
		g_signal_emit_by_name (self, "command::@default", _tmp3_, _tmp3__length1, _tmp4_);
		_g_object_unref0 (kwargs);
		_g_object_unref0 (arglist);
		return;
	}
	_tmp5_ = g_strdup ("@default");
	cmd = _tmp5_;
	_tmp6_ = self->priv->args;
	_tmp6__length1 = self->priv->args_length1;
	_tmp7_ = (_tmp6_ != NULL) ? _vala_array_dup2 (_tmp6_, _tmp6__length1) : ((gpointer) _tmp6_);
	_tmp7__length1 = _tmp6__length1;
	arguments = _tmp7_;
	arguments_length1 = _tmp7__length1;
	_arguments_size_ = arguments_length1;
	_tmp8_ = self->priv->args;
	_tmp8__length1 = self->priv->args_length1;
	_tmp9_ = _tmp8_[0];
	_tmp10_ = string_get (_tmp9_, (glong) 0);
	if (_tmp10_ != '-') {
		gchar** _tmp11_;
		gint _tmp11__length1;
		const gchar* _tmp12_;
		gchar* _tmp13_;
		gchar** _tmp14_;
		gint _tmp14__length1;
		gchar** _tmp15_;
		gint _tmp15__length1;
		gchar** _tmp16_;
		gint _tmp16__length1;
		_tmp11_ = arguments;
		_tmp11__length1 = arguments_length1;
		_tmp12_ = _tmp11_[0];
		_tmp13_ = g_strdup (_tmp12_);
		_g_free0 (cmd);
		cmd = _tmp13_;
		_tmp14_ = arguments;
		_tmp14__length1 = arguments_length1;
		_tmp15_ = arguments;
		_tmp15__length1 = arguments_length1;
		_tmp16_ = ((_tmp14_ + 1) != NULL) ? _vala_array_dup3 (_tmp14_ + 1, _tmp15__length1 - 1) : ((gpointer) (_tmp14_ + 1));
		_tmp16__length1 = _tmp15__length1 - 1;
		arguments = (_vala_array_free (arguments, arguments_length1, (GDestroyNotify) g_free), NULL);
		arguments = _tmp16_;
		arguments_length1 = _tmp16__length1;
		_arguments_size_ = arguments_length1;
	}
	_tmp17_ = arguments;
	_tmp17__length1 = arguments_length1;
	{
		gchar** arg_collection = NULL;
		gint arg_collection_length1 = 0;
		gint _arg_collection_size_ = 0;
		gint arg_it = 0;
		arg_collection = _tmp17_;
		arg_collection_length1 = _tmp17__length1;
		for (arg_it = 0; arg_it < _tmp17__length1; arg_it = arg_it + 1) {
			gchar* _tmp18_;
			gchar* arg = NULL;
			_tmp18_ = g_strdup (arg_collection[arg_it]);
			arg = _tmp18_;
			{
				const gchar* _tmp19_;
				gchar _tmp20_ = '\0';
				_tmp19_ = arg;
				_tmp20_ = string_get (_tmp19_, (glong) 0);
				if (_tmp20_ != '-') {
					GeeList* _tmp21_;
					const gchar* _tmp22_;
					_tmp21_ = arglist;
					_tmp22_ = arg;
					gee_collection_add ((GeeCollection*) _tmp21_, _tmp22_);
				} else {
					const gchar* _tmp23_;
					gchar** _tmp24_;
					gchar** _tmp25_ = NULL;
					gchar** keyvalue;
					gint keyvalue_length1;
					gint _keyvalue_size_;
					const gchar* _tmp26_ = NULL;
					gchar** _tmp27_;
					gint _tmp27__length1;
					GeeMap* _tmp30_;
					gchar** _tmp31_;
					gint _tmp31__length1;
					const gchar* _tmp32_;
					const gchar* _tmp33_;
					_tmp23_ = arg;
					_tmp25_ = _tmp24_ = g_strsplit (_tmp23_, "=", 2);
					keyvalue = _tmp25_;
					keyvalue_length1 = _vala_array_length (_tmp24_);
					_keyvalue_size_ = keyvalue_length1;
					_tmp27_ = keyvalue;
					_tmp27__length1 = keyvalue_length1;
					if (_tmp27__length1 > 1) {
						gchar** _tmp28_;
						gint _tmp28__length1;
						const gchar* _tmp29_;
						_tmp28_ = keyvalue;
						_tmp28__length1 = keyvalue_length1;
						_tmp29_ = _tmp28_[1];
						_tmp26_ = _tmp29_;
					} else {
						_tmp26_ = NULL;
					}
					_tmp30_ = kwargs;
					_tmp31_ = keyvalue;
					_tmp31__length1 = keyvalue_length1;
					_tmp32_ = _tmp31_[0];
					_tmp33_ = _tmp26_;
					gee_map_set (_tmp30_, _tmp32_, _tmp33_);
					keyvalue = (_vala_array_free (keyvalue, keyvalue_length1, (GDestroyNotify) g_free), NULL);
				}
				_g_free0 (arg);
			}
		}
	}
	_tmp35_ = cmd;
	if (g_strcmp0 (_tmp35_, "@default") == 0) {
		_tmp34_ = TRUE;
	} else {
		GeeSet* _tmp36_;
		const gchar* _tmp37_;
		gboolean _tmp38_ = FALSE;
		_tmp36_ = self->priv->commands;
		_tmp37_ = cmd;
		_tmp38_ = gee_collection_contains ((GeeCollection*) _tmp36_, _tmp37_);
		_tmp34_ = _tmp38_;
	}
	_tmp39_ = _tmp34_;
	if (_tmp39_) {
		const gchar* _tmp40_;
		gchar* _tmp41_;
		GeeList* _tmp42_;
		gint _tmp43_ = 0;
		gpointer* _tmp44_ = NULL;
		gchar** _tmp45_;
		gint _tmp45__length1;
		GeeMap* _tmp46_;
		_tmp40_ = cmd;
		_tmp41_ = g_strconcat ("command::", _tmp40_, NULL);
		_tmp42_ = arglist;
		_tmp44_ = gee_collection_to_array ((GeeCollection*) _tmp42_, &_tmp43_);
		_tmp45_ = _tmp44_;
		_tmp45__length1 = _tmp43_;
		_tmp46_ = kwargs;
		g_signal_emit_by_name (self, _tmp41_, _tmp45_, _tmp43_, _tmp46_);
		_tmp45_ = (_vala_array_free (_tmp45_, _tmp45__length1, (GDestroyNotify) g_free), NULL);
		_g_free0 (_tmp41_);
	} else {
		g_signal_emit_by_name (self, "unhandled-command");
	}
	arguments = (_vala_array_free (arguments, arguments_length1, (GDestroyNotify) g_free), NULL);
	_g_free0 (cmd);
	_g_object_unref0 (kwargs);
	_g_object_unref0 (arglist);
}


static void g_cclosure_user_marshal_VOID__BOXED_INT_OBJECT (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data) {
	typedef void (*GMarshalFunc_VOID__BOXED_INT_OBJECT) (gpointer data1, gpointer arg_1, gint arg_2, gpointer arg_3, gpointer data2);
	register GMarshalFunc_VOID__BOXED_INT_OBJECT callback;
	register GCClosure * cc;
	register gpointer data1;
	register gpointer data2;
	cc = (GCClosure *) closure;
	g_return_if_fail (n_param_values == 4);
	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = param_values->data[0].v_pointer;
	} else {
		data1 = param_values->data[0].v_pointer;
		data2 = closure->data;
	}
	callback = (GMarshalFunc_VOID__BOXED_INT_OBJECT) (marshal_data ? marshal_data : cc->callback);
	callback (data1, g_value_get_boxed (param_values + 1), g_value_get_int (param_values + 2), g_value_get_object (param_values + 3), data2);
}


static void steadyflow_core_option_parser_class_init (SteadyflowCoreOptionParserClass * klass) {
	steadyflow_core_option_parser_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (SteadyflowCoreOptionParserPrivate));
	G_OBJECT_CLASS (klass)->finalize = steadyflow_core_option_parser_finalize;
	g_signal_new ("command", STEADYFLOW_CORE_TYPE_OPTION_PARSER, G_SIGNAL_RUN_LAST | G_SIGNAL_DETAILED, 0, NULL, NULL, g_cclosure_user_marshal_VOID__BOXED_INT_OBJECT, G_TYPE_NONE, 3, G_TYPE_STRV, G_TYPE_INT, GEE_TYPE_MAP);
	g_signal_new ("unhandled_command", STEADYFLOW_CORE_TYPE_OPTION_PARSER, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
}


static void steadyflow_core_option_parser_instance_init (SteadyflowCoreOptionParser * self) {
	self->priv = STEADYFLOW_CORE_OPTION_PARSER_GET_PRIVATE (self);
}


static void steadyflow_core_option_parser_finalize (GObject* obj) {
	SteadyflowCoreOptionParser * self;
	self = STEADYFLOW_CORE_OPTION_PARSER (obj);
	self->priv->args = (_vala_array_free (self->priv->args, self->priv->args_length1, (GDestroyNotify) g_free), NULL);
	_g_object_unref0 (self->priv->commands);
	G_OBJECT_CLASS (steadyflow_core_option_parser_parent_class)->finalize (obj);
}


GType steadyflow_core_option_parser_get_type (void) {
	static volatile gsize steadyflow_core_option_parser_type_id__volatile = 0;
	if (g_once_init_enter (&steadyflow_core_option_parser_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (SteadyflowCoreOptionParserClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) steadyflow_core_option_parser_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (SteadyflowCoreOptionParser), 0, (GInstanceInitFunc) steadyflow_core_option_parser_instance_init, NULL };
		GType steadyflow_core_option_parser_type_id;
		steadyflow_core_option_parser_type_id = g_type_register_static (G_TYPE_OBJECT, "SteadyflowCoreOptionParser", &g_define_type_info, 0);
		g_once_init_leave (&steadyflow_core_option_parser_type_id__volatile, steadyflow_core_option_parser_type_id);
	}
	return steadyflow_core_option_parser_type_id__volatile;
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}


static gint _vala_array_length (gpointer array) {
	int length;
	length = 0;
	if (array) {
		while (((gpointer*) array)[length]) {
			length++;
		}
	}
	return length;
}



